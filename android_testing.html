<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Android Testing - Cybersecurity Academy</title>
  <link rel="stylesheet" href="style.css"/>
  <script src="scripts.js" defer></script>
</head>
<body class="dark-theme">

  <header class="site-header">
    <h1>üì± Android Testing</h1>
    <p class="subtitle">Dive deep into mobile security testing for Android applications ‚Äì from static analysis to exploitation</p>
  </header>

  <main class="content">

    <section class="intro">
      <h2>What is Android Application Security Testing?</h2>
      <p>
        Android application testing involves assessing the security of mobile apps built for the Android platform. This includes analyzing the app's code, behavior, network communication, data storage, and interaction with the Android OS. The objective is to identify vulnerabilities before attackers do.
      </p>
    </section>

    <section class="types">
      <h2>üîç Key Phases of Android Testing</h2>

      <div class="card">
        <h3>1. Static Analysis (SAST)</h3>
        <p>Examining the app without executing it. This involves reverse engineering the APK file to analyze code, permissions, hardcoded secrets, and insecure configurations.</p>
      </div>

      <div class="card">
        <h3>2. Dynamic Analysis (DAST)</h3>
        <p>Running the app in a controlled environment to observe runtime behavior, monitor logs, intercept traffic, and trigger vulnerabilities.</p>
      </div>

      <div class="card">
        <h3>3. Reverse Engineering</h3>
        <p>Decoding and understanding compiled Android apps to reveal logic flaws or hidden functionality.</p>
      </div>

      <div class="card">
        <h3>4. Exploitation</h3>
        <p>Actively attempting to exploit discovered vulnerabilities such as insecure storage, activity hijacking, insecure API calls, or insecure communication.</p>
      </div>
    </section>

    <section class="tools">
      <h2>üß∞ Essential Tools</h2>
      <ul>
        <li><strong>APKTool</strong> ‚Äì Decode and rebuild APKs</li>
        <li><strong>MobSF (Mobile Security Framework)</strong> ‚Äì Automated analysis tool for static and dynamic testing</li>
        <li><strong>Burp Suite</strong> ‚Äì Intercept and manipulate HTTP/S traffic</li>
        <li><strong>Frida</strong> ‚Äì Dynamic instrumentation toolkit</li>
        <li><strong>Jadx</strong> ‚Äì Decompile APKs into readable Java source</li>
        <li><strong>ADB (Android Debug Bridge)</strong> ‚Äì Interact with Android device/emulator shell</li>
      </ul>
    </section>

    <section class="step-by-step">
      <h2>‚öôÔ∏è Step-by-Step Android App Testing Workflow</h2>

      <h3>Step 1: Extract APK</h3>
      <p>Use <code>adb pull</code> or download the APK from the Play Store or third-party sources.</p>
      <pre><code>adb shell pm list packages
adb shell pm path com.target.app
adb pull /data/app/com.target.app-1/base.apk</code></pre>

      <h3>Step 2: Decompile APK</h3>
      <p>Use APKTool or jadx to analyze resources and source code.</p>
      <pre><code>apktool d base.apk -o decoded_app
jadx -d source_code base.apk</code></pre>

      <h3>Step 3: Analyze Manifest</h3>
      <p>Inspect <code>AndroidManifest.xml</code> for exported components, permissions, and misconfigurations (e.g., <code>android:debuggable=true</code>).</p>

      <h3>Step 4: Inspect Code</h3>
      <p>Look for hardcoded secrets, API keys, and insecure function calls like <code>WebView.loadUrl()</code>.</p>

      <h3>Step 5: Setup Emulator + Proxy</h3>
      <p>Run the app on an emulator or real device. Configure Burp Suite for traffic interception.</p>
      <pre><code>adb shell settings put global http_proxy 127.0.0.1:8080</code></pre>

      <h3>Step 6: Dynamic Testing with Frida</h3>
      <p>Hook into runtime functions and bypass root detection, SSL pinning, or other checks.</p>
      <pre><code>frida -U -n com.target.app -l ssl_bypass.js</code></pre>
    </section>

    <section class="real-world">
      <h2>üåê Real-World Example</h2>
      <p>While analyzing a fitness app:</p>
      <ul>
        <li>Discovered <code>SharedPreferences</code> storing credentials in plaintext</li>
        <li>Found exposed <code>Activity</code> components with <code>exported=true</code> and no permission checks</li>
        <li>Intercepted insecure HTTP requests using Burp Suite, leaking session tokens</li>
      </ul>
    </section>

    <section class="tips">
      <h2>üí° Practical Tips</h2>
      <ul>
        <li>Use rooted emulators or Genymotion for easier testing</li>
        <li>Check for insecure permissions and exported components</li>
        <li>Analyze network calls ‚Äì look for lack of HTTPS, bad token handling</li>
        <li>Pay attention to native libraries and JNI bindings</li>
        <li>Use automation tools (like MobSF) to save time, but always validate manually</li>
      </ul>
    </section>

    <section class="resources">
      <h2>üìö Learning Resources</h2>
      <ul>
        <li><a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF" target="_blank">MobSF GitHub</a></li>
        <li><a href="https://owasp.org/www-project-mobile-top-10/" target="_blank">OWASP Mobile Top 10</a></li>
        <li><a href="https://developer.android.com/topic/security" target="_blank">Android Security Best Practices</a></li>
        <li><a href="https://www.frida.re/" target="_blank">Frida Documentation</a></li>
        <li><a href="https://github.com/enovella/android-ssl-pinning-bypass" target="_blank">SSL Pinning Bypass Scripts</a></li>
      </ul>
    </section>

  </main>

  <footer class="site-footer">
    <p>BugDrillX ¬© 2025 ‚Äì Learn. Hack. Evolve. powered by <a href="https://pk.linkedin.com/company/scoltech" target="_blank">SCOLTECH</a></p>
  </footer>

</body>
</html>
